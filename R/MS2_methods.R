#' @title exportMSP
#' @param struct RHermesExp object
#' @param ID Index of the MS2Exp that you want to export
#' @param fname Name of the output file, without the .msp termination
#' @description  Exports the superspectra of a given MS2Exp ID into an
#' .msp format file
#' @return An .msp file
#' @examples
#'   if(FALSE){
#'        exportMSP(myHermes, 1, "output")
#'    }
#' @export
exportMSP <- function(struct, ID, fname, idx = NA) {
    sstable <- struct@data@MS2Exp[[ID]]@Ident[[1]]
    if (is.na(idx)) {
        idx <- seq_len(nrow(sstable))
    }
    sink(file = paste0(fname, ".msp"))
    for (i in idx) {
        curss <- sstable[i, ]
        precmz <- curss$precmass
        ssdata <- curss$ssdata[[1]]
        # Write into the .ms file
        cat("Name: Entry ", i, " Apex at ", curss$apex[[1]], " seconds. ",
            "Range: ", curss$start[[1]], "-", curss$end[[1]], "\n", sep = "")
        cat("PRECURSORMZ:", precmz, "\n")
        cat("Comments:", "Generated by RHermes", "\n")
        cat("Num peaks:", nrow(ssdata), "\n")
        for (j in seq_len(nrow(ssdata))) {
            cat(as.numeric(ssdata[j, ]), "\n")
        }
        cat("\n")
    }
    sink()
}



#' @title exportMGF
#' @param struct RHermesExp object
#' @param ID Index of the MS2Exp that you want to export
#' @param fname Name of the output file, without the .mgf termination
#' @description  Exports the superspectra of a given MS2Exp into an
#'  .mgf format file
#' @return An .msf file
#' @examples
#'   if(FALSE){
#'        exportMGF(myHermes, 1, "output")
#'    }
#' @export
exportMGF <- function(struct, ID, fname, idx = NA) {
    sstable <- struct@data@MS2Exp[[ID]]@Ident[[1]]
    charge <- struct@metadata@ExpParam@ion
    if (is.na(idx)) {
        idx <- seq_len(nrow(sstable))
    }
    sink(file = paste0(fname, ".mgf"))
    for (i in idx) {
        curss <- sstable[i, ]
        precmz <- curss$precmass
        ssdata <- curss$ssdata[[1]]
        # Write into the .ms file
        cat("BEGIN IONS\n")
        cat("PEPMASS=", precmz, "\n", sep = "")
        cat("CHARGE=", "1", charge, "\n", sep = "")
        cat("RTINSECONDS=", curss$apex[[1]], "\n", sep = "")
        cat("TITLE=Entry ", i, " Apex at ", curss$apex[[1]], " seconds. ",
            "Range: ", curss$start[[1]], "-", curss$end[[1]], "\n", sep = "")
        for (j in seq_len(nrow(ssdata))) {
            cat(as.numeric(ssdata[j, ]), "\n")
        }
        cat("END IONS\n")
        cat("\n")
    }
    sink()
}

#'@export
setGeneric("exportIdent", function(struct, ms2id, file){
    standardGeneric("exportIdent")
})
setMethod("exportIdent", c("RHermesExp", "numeric", "character"),
function(struct, ms2id, file) {
    ms2 <- struct@data@MS2Exp[[ms2id]]@Ident[[1]]
    ms2 <- ms2[vapply(ms2$results, is.data.frame, logical(1)), ]

    #Extracting hits from inner data.frame
    ms2$hits <- lapply(ms2$results, function(hits) {
        if (!is.data.frame(hits)) {return(hits)}
        hits$formula
    })
    ms2$bestscore <- lapply(ms2$results, function(hits) {
        if (!is.data.frame(hits)) {return("N/A")}
        as.character(round(max(hits$cos), digits = 3))
    })
    ms2 <- dplyr::select(ms2, -c("ssdata", "results"))

    #Adjusting format
    ms2$start <- as.numeric(ms2$start)
    ms2$end <- as.numeric(ms2$end)
    ms2$apex <- as.numeric(ms2$apex)
    ms2$precmass <- as.numeric(ms2$precmass)
    ms2$bestscore <- as.numeric(ms2$bestscore)
    ms2$start <- format(round(ms2$start, 2), nsmall = 2)
    ms2$end <- format(round(ms2$end, 2), nsmall = 2)
    ms2$apex <- format(round(ms2$apex, 2), nsmall = 2)
    ms2$bestscore <- format(round(ms2$bestscore, 4), nsmall = 4)
    ms2$precmass <- format(round(ms2$precmass, 4), nsmall = 4)

    #Collapsing multiple annotations into a single string
    ms2$anot <- lapply(ms2$anot, function(x) {
        paste(x, collapse = " ")
    })
    ms2$hits <- lapply(ms2$hits, function(x) {
        paste(x, collapse = " ")
    })
    ms2$hits <- lapply(ms2$hits, function(x) {
        gsub(pattern = "\n", replacement = "", x = x, )
    })
    ms2$hits <- lapply(ms2$hits, function(x) {
        gsub(pattern = "\t", replacement = "", x = x, )
    })
    write.csv(ms2, file = file)
})

#'@export
setGeneric("whichIdent", function(struct, ms2id){standardGeneric("whichIdent")})
setMethod("whichIdent", c("RHermesExp", "numeric"),
function(struct, ms2id){
    identdf <- struct@data@MS2Exp[[ms2id]]@Ident[[1]]
    which_ID <- which(vapply(identdf$results, is.data.frame, logical(1)))
    return(which_ID)
})


#'@export
setMethod("show", "RHermesMS2Exp", function(object){
    message("Info about this MS2Exp object:")
    show(object@IL)
    hasMS2 <- length(object@Ident) != 0
    if(hasMS2){
        num_entries <- length(unique(object@Ident[["MS2Features"]]$ILentry))
        num_sup <- nrow(object@Ident[["MS2Features"]])
        num_ident <- length(which(vapply(object@Ident[["MS2Features"]]$results,
                                            is.data.frame, logical(1))))
        message(paste0("Number of covered entries: ", num_entries ))
        message(paste0("Number of superspectra: ", num_sup ))
        message(paste0("Identified superspectra: ", num_ident ))
    } else {
        message("No identification was performed")
    }
})


# MS2Networking <- function(struct, ID, costhr) {
#     validObject(struct)
#     MS2Exp <- struct@data@MS2Exp[[ID]]
#     identdf <- MS2Exp@Ident[[1]]
#     withScans <- MS2Exp@Ident[[4]]
#
#     #Tidying info
#     tags <- lapply(seq_along(MS2Exp@Ident[[2]][[2]]), function(ILid) {
#         l <- length(MS2Exp@Ident[[2]][[2]][[ILid]])
#         if (l == 0) {
#             return()
#         }
#         return(paste(rep(withScans[ILid], times = l), seq_len(l),
#             sep = "_"))
#     }) %>% unlist()
#
#     ident_tags <- lapply(seq_len(nrow(identdf)), function(row) {
#         cur <- identdf[row, ]
#         return(data.frame(id = paste(cur$IL_ID, cur$ss, sep = "_"),
#             comp = cur$compound, smiles = cur$smiles,
#             stringsAsFactors = FALSE))
#     }) %>% do.call(rbind, .)
#
#     smiles <- c()
#     for (i in seq_len(nrow(ident_tags))) {
#         cur <- ident_tags[i, ]
#         tomatch <- cur$id
#         smiles <- c(smiles, cur$smiles)
#         tags[tags == cur$id] <- paste(cur$comp, cur$id, sep = "@")
#     }
#     identified <- which(grepl("@", tags, fixed = TRUE))
#
#     subset <- seq_along(tags)
#     #Calculating cosines
#     allspec <- unlist(MS2Exp@Ident[[2]][[2]], recursive = FALSE)[subset]
#     cos <- lapply(allspec, function(pattern) {
#         lapply(allspec, function(query) {
#             MSMScosineSim(pattern, query, minhits = 1, mode = "full")
#         })
#     }) %>% unlist() %>% matrix(nrow = length(allspec), byrow = TRUE)
#     colnames(cos) <- tags[subset]
#     rownames(cos) <- tags[subset]
#
#     #Graph and output
#     gr <- igraph::graph_from_adjacency_matrix(ifelse(cos > costhr,
#         1, 0))
#     wc <- igraph::cluster_walktrap(gr)
#     members <- igraph::membership(wc)
#     gr <- igraph::simplify(gr, remove.multiple = TRUE, remove.loops = TRUE)
#
#     gr <- networkD3::igraph_to_networkD3(gr, group = members)
#
#     #SMILES parsing and plotting to generate images for the network
#     txt <- lapply(smiles, function(smile) {
#         img <- view.image.2d(parse.smiles(smile)[[1]])
#         png("test.png")  #Temp file
#         grid::grid.raster(img)
#         dev.off()
#         return(RCurl::base64Encode(readBin("./test.png", "raw",
#             file.info("./test.png")[1, "size"]), "txt"))
#     })
#     file.remove("test.png")
#
#
#     gr$nodes$shape <- "circle"
#     gr$nodes$image <- NA
#     for (i in seq_along(identified)) {
#         id <- identified[i]
#         gr$nodes$shape[id] <- "image"
#         gr$nodes$image[id] <- paste("data:image/png;base64",
#             txt, sep = ",")
#     }
#     net <- visNetwork(gr$nodes %>% rename(label = name) %>%
#                       mutate(id = seq_len(nrow(gr$nodes)) - 1),
#                       gr$links %>% rename(from = source, to = target),
#                       width = "1200", height = "1200")
#
#     net %<>% visNodes(color = list(background = "lightblue")) %>%
#         visEdges(smooth = FALSE) %>% visPhysics(solver = "barnesHut",
#         stabilization = TRUE)
#
#     net
#     # networkD3::forceNetwork(Links = gr$links, Nodes = gr$nodes,
#     #                         Source = 'source', Target = 'target',
#     #                         NodeID = 'name', Group = 'group',
#     #                         height = 3000, width = 3000, zoom = TRUE,
#     #                         opacity = 0.8)
# }
