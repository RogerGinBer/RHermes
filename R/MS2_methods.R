#' @title exportMSP
#' @param struct RHermesExp object
#' @param ID Index of the MS2Exp that you want to export
#' @param fname Name of the output file, without the .msp termination
#' @description  Exports the superspectra of a given MS2Exp ID into an
#' .msp format file
#' @return An .msp file
#' @examples
#'   if(FALSE){
#'        exportMSP(myHermes, 1, "output")
#'    }
#' @export
exportMSP <- function(struct, ID, fname, idx = NA) {
    sstable <- struct@data@MS2Exp[[ID]]@Ident[[1]]
    if (is.na(idx)) {
        idx <- seq_len(nrow(sstable))
    }
    sink(file = paste0(fname, ".msp"))
    for (i in idx) {
        curss <- sstable[i, ]
        precmz <- curss$precmass
        ssdata <- curss$ssdata[[1]]
        # Write into the .ms file
        cat("Name: Entry ", i, " Apex at ", curss$apex[[1]], " seconds. ",
            "Range: ", curss$start[[1]], "-", curss$end[[1]], "\n", sep = "")
        cat("PRECURSORMZ:", precmz, "\n")
        cat("Comments:", "Generated by RHermes", "\n")
        cat("Num peaks:", nrow(ssdata), "\n")
        for (j in seq_len(nrow(ssdata))) {
            cat(as.numeric(ssdata[j, ]), "\n")
        }
        cat("\n")
    }
    sink()
}



#' @title exportMGF
#' @param struct RHermesExp object
#' @param ID Index of the MS2Exp that you want to export
#' @param fname Name of the output file, without the .mgf termination
#' @description  Exports the superspectra of a given MS2Exp into an
#'  .mgf format file
#' @return An .msf file
#' @examples
#'   if(FALSE){
#'        exportMGF(myHermes, 1, "output")
#'    }
#' @export
exportMGF <- function(struct, ID, fname, idx = NA) {
    sstable <- struct@data@MS2Exp[[ID]]@Ident[[1]]
    charge <- struct@metadata@ExpParam@ion
    if (is.na(idx)) {
        idx <- seq_len(nrow(sstable))
    }
    sink(file = paste0(fname, ".mgf"))
    for (i in idx) {
        curss <- sstable[i, ]
        precmz <- curss$precmass
        ssdata <- curss$ssdata[[1]]
        # Write into the .ms file
        cat("BEGIN IONS\n")
        cat("PEPMASS=", precmz, "\n", sep = "")
        cat("CHARGE=", "1", charge, "\n", sep = "")
        cat("RTINSECONDS=", curss$apex[[1]], "\n", sep = "")
        cat("TITLE=Entry ", i, " Apex at ", curss$apex[[1]], " seconds. ",
            "Range: ", curss$start[[1]], "-", curss$end[[1]], "\n", sep = "")
        for (j in seq_len(nrow(ssdata))) {
            cat(as.numeric(ssdata[j, ]), "\n")
        }
        cat("END IONS\n")
        cat("\n")
    }
    sink()
}

#' @title exportmzML
#' @param struct RHermesExp object
#' @param ID Index of the MS2Exp that you want to export
#' @param fname Name of the output file, without the .mzML termination
#' @description  Exports the superspectra of a given MS2Exp ID into an
#' mzML format file. Warning! The retention time information is not
#' included in the mzML file.
#' @return An .mzML file
#' @examples
#'   if(FALSE){
#'        exportmzML(myHermes, 1, "output")
#'    }
#' @export
exportmzML <- function(struct, ID, fname,idx=NA) {
    Ident <- struct@data@MS2Exp[[ID]]@Ident
    IL <- struct@data@MS2Exp[[ID]]@IL@IL
    MS2Data <- struct@data@MS2Exp[[ID]]@MS2Data
    MS2Features <- Ident$MS2Features
    if(is.null(MS2Features)){
        stop("No MS2 spectra found for that MS2Exp ID index")
    }
    out_file <- paste0(fname, ".mzML")
    if(!is.na(idx)){
        Ident <- Ident[idx]
        IL <- IL[idx, ]
        MS2Data <- MS2Data[idx]
        MS2Features <- MS2Features[idx, ]
        out_file <- paste0(fname, "_",
                            paste(idx[1], idx[length(idx)], sep = "_"), ".mzML")
    }
    minMZ <- struct@metadata@ExpParam@minmz
    maxMZ <- struct@metadata@ExpParam@maxmz
    if(struct@metadata@ExpParam@ion == "+"){
        polValue <- 1
    } else {
        polValue <- 0
    }
    pks <- list() #list of matrices columns = mz intensity
    ## Get the header
    hdr <- structure(list(seqNum = integer(0), acquisitionNum = integer(0),
                    msLevel = integer(0), polarity = integer(0),
                    peaksCount = integer(0), totIonCurrent = numeric(0),
                    retentionTime = numeric(0), basePeakMZ = numeric(0),
                    basePeakIntensity = numeric(0),
                    collisionEnergy = numeric(0),
                    ionisationEnergy = numeric(0), lowMZ = numeric(0),
                    highMZ = numeric(0), precursorScanNum = integer(0),
                    precursorMZ = numeric(0), precursorCharge = integer(0),
                    precursorIntensity = numeric(0),
                    mergedScan = integer(0),
                    mergedResultScanNum = integer(0),
                    mergedResultStartScanNum = integer(0),
                    mergedResultEndScanNum = integer(0),
                    injectionTime = numeric(0), filterString = character(0),
                    spectrumId = character(0), centroided = logical(0),
                    ionMobilityDriftTime = numeric(0),
                    isolationWindowTargetMZ = numeric(0),
                    isolationWindowLowerOffset = numeric(0),
                    isolationWindowUpperOffset = numeric(0),
                    scanWindowLowerLimit = numeric(0),
                    scanWindowUpperLimit = numeric(0)),
                row.names = integer(0), class = "data.frame")


    for(i in seq_len(nrow(MS2Features))){
        precMZ <- MS2Features$precmass[i]
        #Spacing the Hermes scans 0.5s from each other. Original RT information
        #is lost but can be retrieved afterwards.
        rt <- i * 0.5
        for(l in c(1, 2)){
            if(l == 1){
                precInt <- 10000
                ssdata <- matrix(c(precMZ,precInt), nrow = 1, ncol=2)
                #Adding artificial MS2 scans to allow MassFrontier to read the
                #Hermes scans.
                for(r in seq(10, 1)){
                    j <- nrow(hdr) + 1
                    hdr[j, ] <- NA
                    pks <- append(pks,list(ssdata))
                    rt2 <- rt -(0.025 * r)
                    hdr$retentionTime[j] <- rt2
                    hdr$msLevel[j] <- l
                    hdr$polarity[j] <- polValue
                    hdr$peaksCount[j] <- nrow(ssdata)
                    hdr$totIonCurrent[j] <- sum(ssdata[, 2])
                    imax <- which.max(ssdata[, 2])
                    hdr$basePeakMZ[j] <- ssdata[imax, 1]
                    hdr$basePeakIntensity[j] <- ssdata[imax, 2]
                    hdr$ionisationEnergy[j] <- 0
                    hdr$lowMZ[j] <- min(ssdata[, 1])
                    hdr$highMZ[j] <- max(ssdata[, 1])
                    hdr$precursorCharge[j] <- 0
                    hdr$injectionTime[j] <- 100
                    hdr$centroided[j] <- TRUE
                    hdr$scanWindowLowerLimit[j] <- minMZ
                    hdr$scanWindowUpperLimit[j] <- maxMZ
                    if(polValue == 1){
                        polString <- "FTMS + p ESI Full ms ["
                    } else {
                        polString <- "FTMS - p ESI Full ms ["
                    }
                    hdr$filterString[j] <- paste0(polString,
                                                hdr$scanWindowLowerLimit[j],
                                                ".0000-",
                                                hdr$scanWindowUpperLimit[j],
                                                ".0000]")
                }
            } else {
                j <- nrow(hdr) + 1
                hdr[j,] <- NA
                ssdata <- MS2Features$ssdata[[i]]
                ssdata <- ssdata[order(ssdata$mz), ]
                ssdata <- as.matrix(ssdata)
                colnames(ssdata) <- NULL
                pks <- append(pks,list(ssdata))
                rt2 <- rt + 0.025
                hdr$retentionTime[j] <- rt2
                hdr$precursorMZ[j] <- precMZ
                hdr$isolationWindowTargetMZ[j] <- precMZ
                hdr$precursorIntensity[j] <- precInt
                hdr$msLevel[j] <- l
                hdr$polarity[j] <- polValue
                hdr$peaksCount[j] <- nrow(ssdata)
                hdr$totIonCurrent[j] <- sum(ssdata[, 2])
                imax <- which.max(ssdata[, 2])
                hdr$basePeakMZ[j] <- ssdata[imax, 1]
                hdr$basePeakIntensity[j] <- ssdata[imax, 2]
                hdr$collisionEnergy[j] <- 35
                hdr$ionisationEnergy[j] <- 0
                hdr$lowMZ[j] <- min(ssdata[, 1])
                hdr$highMZ[j] <- max(ssdata[, 1])
                hdr$precursorCharge[j] <- 0
                hdr$injectionTime[j] <- 50
                hdr$centroided[j] <- T
                hdr$isolationWindowLowerOffset <- 0.8
                hdr$isolationWindowUpperOffset <- 0.8
                minMZfilter <- minMZ
                maxMZfilter <- max(c(hdr$highMZ[j], hdr$precursorMZ[j]))
                maxMZfilter <- round(maxMZfilter, 0) + 20
                if(polValue == 1){
                    polString2 <- "FTMS + p ESI d Full ms2 "
                } else {
                    polString2 <- "FTMS - p ESI d Full ms2 "
                }
                hdr$filterString[j] <- paste0(polString2,
                                                hdr$precursorMZ[j], "@hcd",
                                                hdr$collisionEnergy[j], ".00 [",
                                                minMZfilter,".0000-",
                                                maxMZfilter,".0000]")
                hdr$scanWindowLowerLimit[j] <- minMZfilter
                hdr$scanWindowUpperLimit[j] <- maxMZfilter
            }
    }
    j <- nrow(hdr) + 1
    hdr[j, ] <- NA
    ssdata <- matrix(c(precMZ, precInt * 0.5), nrow = 1, ncol = 2)
    pks <- append(pks, list(ssdata))
    rt2 <- rt + 0.1
    hdr$retentionTime[j] <- rt2
    hdr$msLevel[j] <- 1
    hdr$polarity[j] <- polValue
    hdr$peaksCount[j] <- nrow(ssdata)
    hdr$totIonCurrent[j] <- sum(ssdata[, 2])
    imax <- which.max(ssdata[, 2])
    hdr$basePeakMZ[j] <- ssdata[imax, 1]
    hdr$basePeakIntensity[j] <- ssdata[imax, 2]
    hdr$ionisationEnergy[j] <- 0
    hdr$lowMZ[j] <- min(ssdata[, 1])
    hdr$highMZ[j] <- max(ssdata[, 1])
    hdr$precursorCharge[j] <- 0
    hdr$injectionTime[j] <- 100
    hdr$centroided[j] <- TRUE
    hdr$scanWindowLowerLimit[j] <- minMZ
    hdr$scanWindowUpperLimit[j] <- maxMZ
    hdr$filterString[j] <- paste0(polString,
                                hdr$scanWindowLowerLimit[j], ".0000-",
                                hdr$scanWindowUpperLimit[j], ".0000]")
    }

    for(i in seq_len(nrow(hdr))){
        if(hdr$msLevel[i] == 1){
            hdr$seqNum[i] <- i
            hdr$acquisitionNum[i] <- i
            j <- i
        } else {
          hdr$seqNum[i] <- i
          hdr$acquisitionNum[i] <- i
          hdr$precursorScanNum[i] <- j
        }

    }
    hdr$spectrumId <- paste0("controllerType=0 controllerNumber=1 scan=",
                            hdr$seqNum)
    rownames(hdr) <- NULL
    
    #Remove if there's already a file named like that
    suppressWarnings(file.remove(out_file))
    mzR::writeMSData(object = pks, file = out_file, header = hdr)
    of <- mzR::openMSfile(out_file)
    mzR::close(of)
}

#'@export
setGeneric("exportIdent", function(struct, ms2id, file){
    standardGeneric("exportIdent")
})
setMethod("exportIdent", c("RHermesExp", "numeric", "character"),
function(struct, ms2id, file) {
    ms2 <- struct@data@MS2Exp[[ms2id]]@Ident[[1]]
    ms2 <- ms2[vapply(ms2$results, is.data.frame, logical(1)), ]

    #Extracting hits from inner data.frame
    ms2$hits <- lapply(ms2$results, function(hits) {
        if (!is.data.frame(hits)) {return(hits)}
        hits$formula
    })
    ms2$bestscore <- lapply(ms2$results, function(hits) {
        if (!is.data.frame(hits)) {return("N/A")}
        as.character(round(max(hits$cos), digits = 3))
    })
    ms2 <- dplyr::select(ms2, -c("ssdata", "results"))

    #Adjusting format
    ms2$start <- as.numeric(ms2$start)
    ms2$end <- as.numeric(ms2$end)
    ms2$apex <- as.numeric(ms2$apex)
    ms2$precmass <- as.numeric(ms2$precmass)
    ms2$bestscore <- as.numeric(ms2$bestscore)
    ms2$start <- format(round(ms2$start, 2), nsmall = 2)
    ms2$end <- format(round(ms2$end, 2), nsmall = 2)
    ms2$apex <- format(round(ms2$apex, 2), nsmall = 2)
    ms2$bestscore <- format(round(ms2$bestscore, 4), nsmall = 4)
    ms2$precmass <- format(round(ms2$precmass, 4), nsmall = 4)

    #Collapsing multiple annotations into a single string
    ms2$anot <- lapply(ms2$anot, function(x) {
        paste(x, collapse = " ")
    })
    ms2$hits <- lapply(ms2$hits, function(x) {
        paste(x, collapse = " ")
    })
    ms2$hits <- lapply(ms2$hits, function(x) {
        gsub(pattern = "\n", replacement = "", x = x, )
    })
    ms2$hits <- lapply(ms2$hits, function(x) {
        gsub(pattern = "\t", replacement = "", x = x, )
    })
    write.csv(ms2, file = file)
})

#'@export
setGeneric("whichIdent", function(struct, ms2id){standardGeneric("whichIdent")})
setMethod("whichIdent", c("RHermesExp", "numeric"),
function(struct, ms2id){
    identdf <- struct@data@MS2Exp[[ms2id]]@Ident[[1]]
    which_ID <- which(vapply(identdf$results, is.data.frame, logical(1)))
    return(which_ID)
})


#'@export
setMethod("show", "RHermesMS2Exp", function(object){
    message("Info about this MS2Exp object:")
    show(object@IL)
    hasMS2 <- length(object@Ident) != 0
    if(hasMS2){
        num_entries <- length(unique(object@Ident[["MS2Features"]]$ILentry))
        num_sup <- nrow(object@Ident[["MS2Features"]])
        num_ident <- length(which(vapply(object@Ident[["MS2Features"]]$results,
                                            is.data.frame, logical(1))))
        message(paste0("Number of covered entries: ", num_entries ))
        message(paste0("Number of superspectra: ", num_sup ))
        message(paste0("Identified superspectra: ", num_ident ))
    } else {
        message("No identification was performed")
    }
})

#'@export
ssNetwork <- function(struct, ID, ss, costhr = 0.8) {
    validObject(struct)
    MS2Exp <- struct@data@MS2Exp[[ID]]
    identdf <- MS2Exp@Ident[[1]]

    allspec <- MS2Exp@Ident$MS2Features$ssdata[ss]
    cos <- lapply(allspec, function(pattern) {
        lapply(allspec, function(query) {
            MSMScosineSim(pattern, query, minhits = 1)
        })
    }) %>% unlist() %>% matrix(nrow = length(allspec), byrow = TRUE)
    
    # #Graph and output
    # gr <- igraph::graph_from_adjacency_matrix(ifelse(cos > costhr,
    #     1, 0))
    # wc <- igraph::cluster_walktrap(gr)
    # members <- igraph::membership(wc)
    # gr <- igraph::simplify(gr, remove.multiple = TRUE, remove.loops = TRUE)
    # 
    # gr <- networkD3::igraph_to_networkD3(gr, group = members)
    # 
    # 
    # net <- visNetwork(gr$nodes %>% rename(label = name) %>%
    #                   mutate(id = seq_len(nrow(gr$nodes)) - 1),
    #                   gr$links %>% rename(from = source, to = target),
    #                   width = "1200", height = "1200")
    # 
    # net %<>% visNodes(color = list(background = "lightblue")) %>%
    #     visEdges(smooth = FALSE) %>% visPhysics(solver = "barnesHut",
    #     stabilization = TRUE)
    # 
    # print(net)
    cos
}
