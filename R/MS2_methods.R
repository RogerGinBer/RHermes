#' @title exportMSP
#' @param struct RHermesExp object
#' @param ID Index of the MS2Exp that you want to export
#' @param fname Name of the output file, without the .msp termination
#' @description  Exports the superspectra of a given MS2Exp ID into an
#' .msp format file
#' @return An .msp file
#' @examples
#'   if(FALSE){
#'        exportMSP(myHermes, 1, "output")
#'    }
#' @export
exportMSP <- function(struct, ID, fname, idx = NA) {
    sstable <- struct@data@MS2Exp[[ID]]@Ident[[1]]
    if (is.na(idx)) {
        idx <- seq_len(nrow(sstable))
    }
    sink(file = paste0(fname, ".msp"))
    for (i in idx) {
        curss <- sstable[i, ]
        precmz <- curss$precmass
        ssdata <- curss$ssdata[[1]]
        # Write into the .ms file
        cat("Name: Entry ", i, " Apex at ", curss$apex[[1]], " seconds. ",
            "Range: ", curss$start[[1]], "-", curss$end[[1]], "\n", sep = "")
        cat("PRECURSORMZ:", precmz, "\n")
        cat("Comments:", "Generated by RHermes", "\n")
        cat("Num peaks:", nrow(ssdata), "\n")
        for (j in seq_len(nrow(ssdata))) {
            cat(as.numeric(ssdata[j, ]), "\n")
        }
        cat("\n")
    }
    sink()
}



#' @title exportMGF
#' @param struct RHermesExp object
#' @param ID Index of the MS2Exp that you want to export
#' @param fname Name of the output file, without the .mgf termination
#' @description  Exports the superspectra of a given MS2Exp into an
#'  .mgf format file
#' @return An .msf file
#' @examples
#'   if(FALSE){
#'        exportMGF(myHermes, 1, "output")
#'    }
#' @export
exportMGF <- function(struct, ID, fname, idx = NA) {
    sstable <- struct@data@MS2Exp[[ID]]@Ident[[1]]
    charge <- struct@metadata@ExpParam@ion
    if (is.na(idx)) {
        idx <- seq_len(nrow(sstable))
    }
    sink(file = paste0(fname, ".mgf"))
    for (i in idx) {
        curss <- sstable[i, ]
        precmz <- curss$precmass
        ssdata <- curss$ssdata[[1]]
        # Write into the .ms file
        cat("BEGIN IONS\n")
        cat("PEPMASS=", precmz, "\n", sep = "")
        cat("CHARGE=", "1", charge, "\n", sep = "")
        cat("RTINSECONDS=", curss$apex[[1]], "\n", sep = "")
        cat("TITLE=Entry ", i, " Apex at ", curss$apex[[1]], " seconds. ",
            "Range: ", curss$start[[1]], "-", curss$end[[1]], "\n", sep = "")
        for (j in seq_len(nrow(ssdata))) {
            cat(as.numeric(ssdata[j, ]), "\n")
        }
        cat("END IONS\n")
        cat("\n")
    }
    sink()
}

#' @title exportmzML
#' @param struct RHermesExp object
#' @param ID Index of the MS2Exp that you want to export
#' @param fname Name of the output file, without the .mzML termination
#' @description  Exports the superspectra of a given MS2Exp ID into an
#' mzML format file. Warning! The retention time information is not 
#' included in the mzML file.
#' @return An .mzML file
#' @examples
#'   if(FALSE){
#'        exportmzML(myHermes, 1, "output")
#'    }
#' @export
exportmzML <- function(struct, ID, fname,idx=NA) {
  Ident <- struct@data@MS2Exp[[ID]]@Ident
  IL <- struct@data@MS2Exp[[ID]]@IL@IL
  MS2Data <- struct@data@MS2Exp[[ID]]@MS2Data
  MS2Features <- Ident$MS2Features
  if(is.null(MS2Features)){stop("No MS2 spectra found for that MS2Exp ID index")}
  out_file <- paste0(fname, ".mzML")
  if(!is.na(idx)){
    Ident <- Ident[idx]
    IL <- IL[sidx,]
    MS2Data <- MS2Data[idx]
    MS2Features <- MS2Features[idx,]
    out_file <- paste0(fname,"_",paste(idx[1],idx[length(idx)],sep="_"), ".mzML")
  }
  minMZ <- ABres@metadata@ExpParam@minmz
  maxMZ <- ABres@metadata@ExpParam@maxmz
  if(ABres@metadata@ExpParam@ion=="+"){
    polValue <- 1
  }else{
    polValue <- 0
  }
  pks <- list() #list of matrices columns = mz intensity
  ## Get the header
  hdr <- structure(list(seqNum = integer(0), acquisitionNum = integer(0), 
                        msLevel = integer(0), polarity = integer(0), 
                        peaksCount = integer(0), totIonCurrent = numeric(0),
                        retentionTime = numeric(0), basePeakMZ = numeric(0), 
                        basePeakIntensity = numeric(0), 
                        collisionEnergy = numeric(0), 
                        ionisationEnergy = numeric(0), lowMZ = numeric(0), 
                        highMZ = numeric(0), precursorScanNum = integer(0),
                        precursorMZ = numeric(0), precursorCharge = integer(0),
                        precursorIntensity = numeric(0), mergedScan = integer(0),
                        mergedResultScanNum = integer(0), 
                        mergedResultStartScanNum = integer(0), 
                        mergedResultEndScanNum = integer(0), 
                        injectionTime = numeric(0), filterString = character(0), 
                        spectrumId = character(0), centroided = logical(0), 
                        ionMobilityDriftTime = numeric(0), 
                        isolationWindowTargetMZ = numeric(0), 
                        isolationWindowLowerOffset = numeric(0), 
                        isolationWindowUpperOffset = numeric(0), 
                        scanWindowLowerLimit = numeric(0), 
                        scanWindowUpperLimit = numeric(0)), 
                   row.names = integer(0), class = "data.frame")
  
  
  for(i in 1:nrow(MS2Features)){ 
    precMZ <- MS2Features$precmass[i] 
    rt <- i*0.5
    for(l in 1:2){
      if(l==1){
        precInt <- 10000
        ssdata <- matrix(c(precMZ,precInt),nrow = 1,ncol=2)
        for(r in 10:1){
          j <- nrow(hdr)+1
          hdr[j,] <- NA
          pks <- append(pks,list(ssdata))
          rt2 <- rt -(0.025*r)
          hdr$retentionTime[j] <- rt2
          hdr$msLevel[j] <- l
          hdr$polarity[j] <- polValue
          hdr$peaksCount[j] <- nrow(ssdata)
          hdr$totIonCurrent[j] <- sum(ssdata[,2])
          imax <- which.max(ssdata[,2])
          hdr$basePeakMZ[j] <- ssdata[imax,1]
          hdr$basePeakIntensity[j] <- ssdata[imax,2]
          hdr$ionisationEnergy[j] <- 0
          hdr$lowMZ[j] <- min(ssdata[,1])
          hdr$highMZ[j] <- max(ssdata[,1])
          hdr$precursorCharge[j] <- 0
          hdr$injectionTime[j] <- 100
          hdr$centroided[j] <- T
          hdr$scanWindowLowerLimit[j] <- minMZ
          hdr$scanWindowUpperLimit[j] <- maxMZ
          if(polValue==1){
            polString <- "FTMS + p ESI Full ms ["
          }else{
            polString <- "FTMS - p ESI Full ms ["
          }
          hdr$filterString[j] <- paste0(polString, 
                                        hdr$scanWindowLowerLimit[j],".0000-",
                                        hdr$scanWindowUpperLimit[j],".0000]")
        }
      }else{
        j <- nrow(hdr)+1
        hdr[j,] <- NA
        ssdata <- MS2Features$ssdata[[i]] 
        ssdata <- ssdata[order(ssdata$mz),]
        ssdata <- as.matrix(ssdata)
        colnames(ssdata) <- NULL
        pks <- append(pks,list(ssdata))
        rt2 <- rt+0.025
        hdr$retentionTime[j] <- rt2
        hdr$precursorMZ[j] <- precMZ
        hdr$isolationWindowTargetMZ[j] <- precMZ
        hdr$precursorIntensity[j] <- precInt
        hdr$msLevel[j] <- l
        hdr$polarity[j] <- polValue
        hdr$peaksCount[j] <- nrow(ssdata)
        hdr$totIonCurrent[j] <- sum(ssdata[,2])
        imax <- which.max(ssdata[,2])
        hdr$basePeakMZ[j] <- ssdata[imax,1]
        hdr$basePeakIntensity[j] <- ssdata[imax,2]
        hdr$collisionEnergy[j] <- 35
        hdr$ionisationEnergy[j] <- 0
        hdr$lowMZ[j] <- min(ssdata[,1])
        hdr$highMZ[j] <- max(ssdata[,1])
        hdr$precursorCharge[j] <- 0
        hdr$injectionTime[j] <- 50
        hdr$centroided[j] <- T
        hdr$isolationWindowLowerOffset <- 0.8
        hdr$isolationWindowUpperOffset <- 0.8
        minMZfilter <- minMZ
        maxMZfilter <- max(c(hdr$highMZ[j],hdr$precursorMZ[j]))
        maxMZfilter <- round(maxMZfilter,0)+20
        if(polValue==1){
          polString2 <- "FTMS + p ESI d Full ms2 "
        }else{
          polString2 <- "FTMS - p ESI d Full ms2 "
        }
        hdr$filterString[j] <- paste0(polString2,
                                      hdr$precursorMZ[j],"@hcd",
                                      hdr$collisionEnergy[j],".00 [",
                                      minMZfilter,".0000-",
                                      maxMZfilter,".0000]")
        hdr$scanWindowLowerLimit[j] <- minMZfilter 
        hdr$scanWindowUpperLimit[j] <- maxMZfilter
      }
    }
    j <- nrow(hdr)+1
    hdr[j,] <- NA
    ssdata <- matrix(c(precMZ,precInt*0.5),nrow = 1,ncol=2)
    pks <- append(pks,list(ssdata))
    rt2 <- rt+0.1
    hdr$retentionTime[j] <- rt2
    hdr$msLevel[j] <- 1
    hdr$polarity[j] <- polValue
    hdr$peaksCount[j] <- nrow(ssdata)
    hdr$totIonCurrent[j] <- sum(ssdata[,2])
    imax <- which.max(ssdata[,2])
    hdr$basePeakMZ[j] <- ssdata[imax,1]
    hdr$basePeakIntensity[j] <- ssdata[imax,2]
    hdr$ionisationEnergy[j] <- 0
    hdr$lowMZ[j] <- min(ssdata[,1])
    hdr$highMZ[j] <- max(ssdata[,1])
    hdr$precursorCharge[j] <- 0
    hdr$injectionTime[j] <- 100
    hdr$centroided[j] <- T
    hdr$scanWindowLowerLimit[j] <- minMZ
    hdr$scanWindowUpperLimit[j] <- maxMZ
    hdr$filterString[j] <- paste0(polString,
                                  hdr$scanWindowLowerLimit[j],".0000-",
                                  hdr$scanWindowUpperLimit[j],".0000]")
  }
  
  for(i in 1:nrow(hdr)){
    if(hdr$msLevel[i]==1){
      hdr$seqNum[i] <- i
      hdr$acquisitionNum[i] <- i
      j <- i
    }else{
      hdr$seqNum[i] <- i
      hdr$acquisitionNum[i] <- i
      hdr$precursorScanNum[i] <- j
    }
    
  }
  hdr$spectrumId <- paste0("controllerType=0 controllerNumber=1 scan=",
                           hdr$seqNum)
  rownames(hdr) <- NULL
  file.remove(out_file)
  mzR::writeMSData(object = pks, file = out_file, header = hdr)
  of <- mzR::openMSfile(out_file)
  mzR::close(of)
}

#'@export
setGeneric("exportIdent", function(struct, ms2id, file){
    standardGeneric("exportIdent")
})
setMethod("exportIdent", c("RHermesExp", "numeric", "character"),
function(struct, ms2id, file) {
    ms2 <- struct@data@MS2Exp[[ms2id]]@Ident[[1]]
    ms2 <- ms2[vapply(ms2$results, is.data.frame, logical(1)), ]

    #Extracting hits from inner data.frame
    ms2$hits <- lapply(ms2$results, function(hits) {
        if (!is.data.frame(hits)) {return(hits)}
        hits$formula
    })
    ms2$bestscore <- lapply(ms2$results, function(hits) {
        if (!is.data.frame(hits)) {return("N/A")}
        as.character(round(max(hits$cos), digits = 3))
    })
    ms2 <- dplyr::select(ms2, -c("ssdata", "results"))

    #Adjusting format
    ms2$start <- as.numeric(ms2$start)
    ms2$end <- as.numeric(ms2$end)
    ms2$apex <- as.numeric(ms2$apex)
    ms2$precmass <- as.numeric(ms2$precmass)
    ms2$bestscore <- as.numeric(ms2$bestscore)
    ms2$start <- format(round(ms2$start, 2), nsmall = 2)
    ms2$end <- format(round(ms2$end, 2), nsmall = 2)
    ms2$apex <- format(round(ms2$apex, 2), nsmall = 2)
    ms2$bestscore <- format(round(ms2$bestscore, 4), nsmall = 4)
    ms2$precmass <- format(round(ms2$precmass, 4), nsmall = 4)

    #Collapsing multiple annotations into a single string
    ms2$anot <- lapply(ms2$anot, function(x) {
        paste(x, collapse = " ")
    })
    ms2$hits <- lapply(ms2$hits, function(x) {
        paste(x, collapse = " ")
    })
    ms2$hits <- lapply(ms2$hits, function(x) {
        gsub(pattern = "\n", replacement = "", x = x, )
    })
    ms2$hits <- lapply(ms2$hits, function(x) {
        gsub(pattern = "\t", replacement = "", x = x, )
    })
    write.csv(ms2, file = file)
})

#'@export
setGeneric("whichIdent", function(struct, ms2id){standardGeneric("whichIdent")})
setMethod("whichIdent", c("RHermesExp", "numeric"),
function(struct, ms2id){
    identdf <- struct@data@MS2Exp[[ms2id]]@Ident[[1]]
    which_ID <- which(vapply(identdf$results, is.data.frame, logical(1)))
    return(which_ID)
})


#'@export
setMethod("show", "RHermesMS2Exp", function(object){
    message("Info about this MS2Exp object:")
    show(object@IL)
    hasMS2 <- length(object@Ident) != 0
    if(hasMS2){
        num_entries <- length(unique(object@Ident[["MS2Features"]]$ILentry))
        num_sup <- nrow(object@Ident[["MS2Features"]])
        num_ident <- length(which(vapply(object@Ident[["MS2Features"]]$results,
                                            is.data.frame, logical(1))))
        message(paste0("Number of covered entries: ", num_entries ))
        message(paste0("Number of superspectra: ", num_sup ))
        message(paste0("Identified superspectra: ", num_ident ))
    } else {
        message("No identification was performed")
    }
})


# MS2Networking <- function(struct, ID, costhr) {
#     validObject(struct)
#     MS2Exp <- struct@data@MS2Exp[[ID]]
#     identdf <- MS2Exp@Ident[[1]]
#     withScans <- MS2Exp@Ident[[4]]
#
#     #Tidying info
#     tags <- lapply(seq_along(MS2Exp@Ident[[2]][[2]]), function(ILid) {
#         l <- length(MS2Exp@Ident[[2]][[2]][[ILid]])
#         if (l == 0) {
#             return()
#         }
#         return(paste(rep(withScans[ILid], times = l), seq_len(l),
#             sep = "_"))
#     }) %>% unlist()
#
#     ident_tags <- lapply(seq_len(nrow(identdf)), function(row) {
#         cur <- identdf[row, ]
#         return(data.frame(id = paste(cur$IL_ID, cur$ss, sep = "_"),
#             comp = cur$compound, smiles = cur$smiles,
#             stringsAsFactors = FALSE))
#     }) %>% do.call(rbind, .)
#
#     smiles <- c()
#     for (i in seq_len(nrow(ident_tags))) {
#         cur <- ident_tags[i, ]
#         tomatch <- cur$id
#         smiles <- c(smiles, cur$smiles)
#         tags[tags == cur$id] <- paste(cur$comp, cur$id, sep = "@")
#     }
#     identified <- which(grepl("@", tags, fixed = TRUE))
#
#     subset <- seq_along(tags)
#     #Calculating cosines
#     allspec <- unlist(MS2Exp@Ident[[2]][[2]], recursive = FALSE)[subset]
#     cos <- lapply(allspec, function(pattern) {
#         lapply(allspec, function(query) {
#             MSMScosineSim(pattern, query, minhits = 1, mode = "full")
#         })
#     }) %>% unlist() %>% matrix(nrow = length(allspec), byrow = TRUE)
#     colnames(cos) <- tags[subset]
#     rownames(cos) <- tags[subset]
#
#     #Graph and output
#     gr <- igraph::graph_from_adjacency_matrix(ifelse(cos > costhr,
#         1, 0))
#     wc <- igraph::cluster_walktrap(gr)
#     members <- igraph::membership(wc)
#     gr <- igraph::simplify(gr, remove.multiple = TRUE, remove.loops = TRUE)
#
#     gr <- networkD3::igraph_to_networkD3(gr, group = members)
#
#     #SMILES parsing and plotting to generate images for the network
#     txt <- lapply(smiles, function(smile) {
#         img <- view.image.2d(parse.smiles(smile)[[1]])
#         png("test.png")  #Temp file
#         grid::grid.raster(img)
#         dev.off()
#         return(RCurl::base64Encode(readBin("./test.png", "raw",
#             file.info("./test.png")[1, "size"]), "txt"))
#     })
#     file.remove("test.png")
#
#
#     gr$nodes$shape <- "circle"
#     gr$nodes$image <- NA
#     for (i in seq_along(identified)) {
#         id <- identified[i]
#         gr$nodes$shape[id] <- "image"
#         gr$nodes$image[id] <- paste("data:image/png;base64",
#             txt, sep = ",")
#     }
#     net <- visNetwork(gr$nodes %>% rename(label = name) %>%
#                       mutate(id = seq_len(nrow(gr$nodes)) - 1),
#                       gr$links %>% rename(from = source, to = target),
#                       width = "1200", height = "1200")
#
#     net %<>% visNodes(color = list(background = "lightblue")) %>%
#         visEdges(smooth = FALSE) %>% visPhysics(solver = "barnesHut",
#         stabilization = TRUE)
#
#     net
#     # networkD3::forceNetwork(Links = gr$links, Nodes = gr$nodes,
#     #                         Source = 'source', Target = 'target',
#     #                         NodeID = 'name', Group = 'group',
#     #                         height = 3000, width = 3000, zoom = TRUE,
#     #                         opacity = 0.8)
# }
